{"ast":null,"code":"/*!\n * Masonry v4.2.2\n * Cascading grid layout library\n * https://masonry.desandro.com\n * MIT License\n * by David DeSandro\n */\n(function (window, factory) {\n  // universal module definition\n\n  /* jshint strict: false */\n\n  /*globals define, module, require */\n  if (typeof define == 'function' && define.amd) {\n    // AMD\n    define(['outlayer/outlayer', 'get-size/get-size'], factory);\n  } else if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(require('outlayer'), require('get-size'));\n  } else {\n    // browser global\n    window.Masonry = factory(window.Outlayer, window.getSize);\n  }\n})(window, function factory(Outlayer, getSize) {\n  'use strict'; // -------------------------- masonryDefinition -------------------------- //\n  // create an Outlayer layout class\n\n  var Masonry = Outlayer.create('masonry'); // isFitWidth -> fitWidth\n\n  Masonry.compatOptions.fitWidth = 'isFitWidth';\n  var proto = Masonry.prototype;\n\n  proto._resetLayout = function () {\n    this.getSize();\n\n    this._getMeasurement('columnWidth', 'outerWidth');\n\n    this._getMeasurement('gutter', 'outerWidth');\n\n    this.measureColumns(); // reset column Y\n\n    this.colYs = [];\n\n    for (var i = 0; i < this.cols; i++) {\n      this.colYs.push(0);\n    }\n\n    this.maxY = 0;\n    this.horizontalColIndex = 0;\n  };\n\n  proto.measureColumns = function () {\n    this.getContainerWidth(); // if columnWidth is 0, default to outerWidth of first item\n\n    if (!this.columnWidth) {\n      var firstItem = this.items[0];\n      var firstItemElem = firstItem && firstItem.element; // columnWidth fall back to item of first element\n\n      this.columnWidth = firstItemElem && getSize(firstItemElem).outerWidth || // if first elem has no width, default to size of container\n      this.containerWidth;\n    }\n\n    var columnWidth = this.columnWidth += this.gutter; // calculate columns\n\n    var containerWidth = this.containerWidth + this.gutter;\n    var cols = containerWidth / columnWidth; // fix rounding errors, typically with gutters\n\n    var excess = columnWidth - containerWidth % columnWidth; // if overshoot is less than a pixel, round up, otherwise floor it\n\n    var mathMethod = excess && excess < 1 ? 'round' : 'floor';\n    cols = Math[mathMethod](cols);\n    this.cols = Math.max(cols, 1);\n  };\n\n  proto.getContainerWidth = function () {\n    // container is parent if fit width\n    var isFitWidth = this._getOption('fitWidth');\n\n    var container = isFitWidth ? this.element.parentNode : this.element; // check that this.size and size are there\n    // IE8 triggers resize on body size change, so they might not be\n\n    var size = getSize(container);\n    this.containerWidth = size && size.innerWidth;\n  };\n\n  proto._getItemLayoutPosition = function (item) {\n    item.getSize(); // how many columns does this brick span\n\n    var remainder = item.size.outerWidth % this.columnWidth;\n    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil'; // round if off by 1 pixel, otherwise use ceil\n\n    var colSpan = Math[mathMethod](item.size.outerWidth / this.columnWidth);\n    colSpan = Math.min(colSpan, this.cols); // use horizontal or top column position\n\n    var colPosMethod = this.options.horizontalOrder ? '_getHorizontalColPosition' : '_getTopColPosition';\n    var colPosition = this[colPosMethod](colSpan, item); // position the brick\n\n    var position = {\n      x: this.columnWidth * colPosition.col,\n      y: colPosition.y\n    }; // apply setHeight to necessary columns\n\n    var setHeight = colPosition.y + item.size.outerHeight;\n    var setMax = colSpan + colPosition.col;\n\n    for (var i = colPosition.col; i < setMax; i++) {\n      this.colYs[i] = setHeight;\n    }\n\n    return position;\n  };\n\n  proto._getTopColPosition = function (colSpan) {\n    var colGroup = this._getTopColGroup(colSpan); // get the minimum Y value from the columns\n\n\n    var minimumY = Math.min.apply(Math, colGroup);\n    return {\n      col: colGroup.indexOf(minimumY),\n      y: minimumY\n    };\n  };\n  /**\n   * @param {Number} colSpan - number of columns the element spans\n   * @returns {Array} colGroup\n   */\n\n\n  proto._getTopColGroup = function (colSpan) {\n    if (colSpan < 2) {\n      // if brick spans only one column, use all the column Ys\n      return this.colYs;\n    }\n\n    var colGroup = []; // how many different places could this brick fit horizontally\n\n    var groupCount = this.cols + 1 - colSpan; // for each group potential horizontal position\n\n    for (var i = 0; i < groupCount; i++) {\n      colGroup[i] = this._getColGroupY(i, colSpan);\n    }\n\n    return colGroup;\n  };\n\n  proto._getColGroupY = function (col, colSpan) {\n    if (colSpan < 2) {\n      return this.colYs[col];\n    } // make an array of colY values for that one group\n\n\n    var groupColYs = this.colYs.slice(col, col + colSpan); // and get the max value of the array\n\n    return Math.max.apply(Math, groupColYs);\n  }; // get column position based on horizontal index. #873\n\n\n  proto._getHorizontalColPosition = function (colSpan, item) {\n    var col = this.horizontalColIndex % this.cols;\n    var isOver = colSpan > 1 && col + colSpan > this.cols; // shift to next row if item can't fit on current row\n\n    col = isOver ? 0 : col; // don't let zero-size items take up space\n\n    var hasSize = item.size.outerWidth && item.size.outerHeight;\n    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;\n    return {\n      col: col,\n      y: this._getColGroupY(col, colSpan)\n    };\n  };\n\n  proto._manageStamp = function (stamp) {\n    var stampSize = getSize(stamp);\n\n    var offset = this._getElementOffset(stamp); // get the columns that this stamp affects\n\n\n    var isOriginLeft = this._getOption('originLeft');\n\n    var firstX = isOriginLeft ? offset.left : offset.right;\n    var lastX = firstX + stampSize.outerWidth;\n    var firstCol = Math.floor(firstX / this.columnWidth);\n    firstCol = Math.max(0, firstCol);\n    var lastCol = Math.floor(lastX / this.columnWidth); // lastCol should not go over if multiple of columnWidth #425\n\n    lastCol -= lastX % this.columnWidth ? 0 : 1;\n    lastCol = Math.min(this.cols - 1, lastCol); // set colYs to bottom of the stamp\n\n    var isOriginTop = this._getOption('originTop');\n\n    var stampMaxY = (isOriginTop ? offset.top : offset.bottom) + stampSize.outerHeight;\n\n    for (var i = firstCol; i <= lastCol; i++) {\n      this.colYs[i] = Math.max(stampMaxY, this.colYs[i]);\n    }\n  };\n\n  proto._getContainerSize = function () {\n    this.maxY = Math.max.apply(Math, this.colYs);\n    var size = {\n      height: this.maxY\n    };\n\n    if (this._getOption('fitWidth')) {\n      size.width = this._getContainerFitWidth();\n    }\n\n    return size;\n  };\n\n  proto._getContainerFitWidth = function () {\n    var unusedCols = 0; // count unused columns\n\n    var i = this.cols;\n\n    while (--i) {\n      if (this.colYs[i] !== 0) {\n        break;\n      }\n\n      unusedCols++;\n    } // fit container to columns that have been used\n\n\n    return (this.cols - unusedCols) * this.columnWidth - this.gutter;\n  };\n\n  proto.needsResizeLayout = function () {\n    var previousWidth = this.containerWidth;\n    this.getContainerWidth();\n    return previousWidth != this.containerWidth;\n  };\n\n  return Masonry;\n});","map":{"version":3,"sources":["C:/Users/osos1/Downloads/reservation CTRL +/theme/miranda/miranda-product/node_modules/masonry-layout/masonry.js"],"names":["window","factory","define","amd","module","exports","require","Masonry","Outlayer","getSize","create","compatOptions","fitWidth","proto","prototype","_resetLayout","_getMeasurement","measureColumns","colYs","i","cols","push","maxY","horizontalColIndex","getContainerWidth","columnWidth","firstItem","items","firstItemElem","element","outerWidth","containerWidth","gutter","excess","mathMethod","Math","max","isFitWidth","_getOption","container","parentNode","size","innerWidth","_getItemLayoutPosition","item","remainder","colSpan","min","colPosMethod","options","horizontalOrder","colPosition","position","x","col","y","setHeight","outerHeight","setMax","_getTopColPosition","colGroup","_getTopColGroup","minimumY","apply","indexOf","groupCount","_getColGroupY","groupColYs","slice","_getHorizontalColPosition","isOver","hasSize","_manageStamp","stamp","stampSize","offset","_getElementOffset","isOriginLeft","firstX","left","right","lastX","firstCol","floor","lastCol","isOriginTop","stampMaxY","top","bottom","_getContainerSize","height","width","_getContainerFitWidth","unusedCols","needsResizeLayout","previousWidth"],"mappings":"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","sourcesContent":["/*!\n * Masonry v4.2.2\n * Cascading grid layout library\n * https://masonry.desandro.com\n * MIT License\n * by David DeSandro\n */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( typeof define == 'function' && define.amd ) {\n    // AMD\n    define( [\n        'outlayer/outlayer',\n        'get-size/get-size'\n      ],\n      factory );\n  } else if ( typeof module == 'object' && module.exports ) {\n    // CommonJS\n    module.exports = factory(\n      require('outlayer'),\n      require('get-size')\n    );\n  } else {\n    // browser global\n    window.Masonry = factory(\n      window.Outlayer,\n      window.getSize\n    );\n  }\n\n}( window, function factory( Outlayer, getSize ) {\n\n'use strict';\n\n// -------------------------- masonryDefinition -------------------------- //\n\n  // create an Outlayer layout class\n  var Masonry = Outlayer.create('masonry');\n  // isFitWidth -> fitWidth\n  Masonry.compatOptions.fitWidth = 'isFitWidth';\n\n  var proto = Masonry.prototype;\n\n  proto._resetLayout = function() {\n    this.getSize();\n    this._getMeasurement( 'columnWidth', 'outerWidth' );\n    this._getMeasurement( 'gutter', 'outerWidth' );\n    this.measureColumns();\n\n    // reset column Y\n    this.colYs = [];\n    for ( var i=0; i < this.cols; i++ ) {\n      this.colYs.push( 0 );\n    }\n\n    this.maxY = 0;\n    this.horizontalColIndex = 0;\n  };\n\n  proto.measureColumns = function() {\n    this.getContainerWidth();\n    // if columnWidth is 0, default to outerWidth of first item\n    if ( !this.columnWidth ) {\n      var firstItem = this.items[0];\n      var firstItemElem = firstItem && firstItem.element;\n      // columnWidth fall back to item of first element\n      this.columnWidth = firstItemElem && getSize( firstItemElem ).outerWidth ||\n        // if first elem has no width, default to size of container\n        this.containerWidth;\n    }\n\n    var columnWidth = this.columnWidth += this.gutter;\n\n    // calculate columns\n    var containerWidth = this.containerWidth + this.gutter;\n    var cols = containerWidth / columnWidth;\n    // fix rounding errors, typically with gutters\n    var excess = columnWidth - containerWidth % columnWidth;\n    // if overshoot is less than a pixel, round up, otherwise floor it\n    var mathMethod = excess && excess < 1 ? 'round' : 'floor';\n    cols = Math[ mathMethod ]( cols );\n    this.cols = Math.max( cols, 1 );\n  };\n\n  proto.getContainerWidth = function() {\n    // container is parent if fit width\n    var isFitWidth = this._getOption('fitWidth');\n    var container = isFitWidth ? this.element.parentNode : this.element;\n    // check that this.size and size are there\n    // IE8 triggers resize on body size change, so they might not be\n    var size = getSize( container );\n    this.containerWidth = size && size.innerWidth;\n  };\n\n  proto._getItemLayoutPosition = function( item ) {\n    item.getSize();\n    // how many columns does this brick span\n    var remainder = item.size.outerWidth % this.columnWidth;\n    var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';\n    // round if off by 1 pixel, otherwise use ceil\n    var colSpan = Math[ mathMethod ]( item.size.outerWidth / this.columnWidth );\n    colSpan = Math.min( colSpan, this.cols );\n    // use horizontal or top column position\n    var colPosMethod = this.options.horizontalOrder ?\n      '_getHorizontalColPosition' : '_getTopColPosition';\n    var colPosition = this[ colPosMethod ]( colSpan, item );\n    // position the brick\n    var position = {\n      x: this.columnWidth * colPosition.col,\n      y: colPosition.y\n    };\n    // apply setHeight to necessary columns\n    var setHeight = colPosition.y + item.size.outerHeight;\n    var setMax = colSpan + colPosition.col;\n    for ( var i = colPosition.col; i < setMax; i++ ) {\n      this.colYs[i] = setHeight;\n    }\n\n    return position;\n  };\n\n  proto._getTopColPosition = function( colSpan ) {\n    var colGroup = this._getTopColGroup( colSpan );\n    // get the minimum Y value from the columns\n    var minimumY = Math.min.apply( Math, colGroup );\n\n    return {\n      col: colGroup.indexOf( minimumY ),\n      y: minimumY,\n    };\n  };\n\n  /**\n   * @param {Number} colSpan - number of columns the element spans\n   * @returns {Array} colGroup\n   */\n  proto._getTopColGroup = function( colSpan ) {\n    if ( colSpan < 2 ) {\n      // if brick spans only one column, use all the column Ys\n      return this.colYs;\n    }\n\n    var colGroup = [];\n    // how many different places could this brick fit horizontally\n    var groupCount = this.cols + 1 - colSpan;\n    // for each group potential horizontal position\n    for ( var i = 0; i < groupCount; i++ ) {\n      colGroup[i] = this._getColGroupY( i, colSpan );\n    }\n    return colGroup;\n  };\n\n  proto._getColGroupY = function( col, colSpan ) {\n    if ( colSpan < 2 ) {\n      return this.colYs[ col ];\n    }\n    // make an array of colY values for that one group\n    var groupColYs = this.colYs.slice( col, col + colSpan );\n    // and get the max value of the array\n    return Math.max.apply( Math, groupColYs );\n  };\n\n  // get column position based on horizontal index. #873\n  proto._getHorizontalColPosition = function( colSpan, item ) {\n    var col = this.horizontalColIndex % this.cols;\n    var isOver = colSpan > 1 && col + colSpan > this.cols;\n    // shift to next row if item can't fit on current row\n    col = isOver ? 0 : col;\n    // don't let zero-size items take up space\n    var hasSize = item.size.outerWidth && item.size.outerHeight;\n    this.horizontalColIndex = hasSize ? col + colSpan : this.horizontalColIndex;\n\n    return {\n      col: col,\n      y: this._getColGroupY( col, colSpan ),\n    };\n  };\n\n  proto._manageStamp = function( stamp ) {\n    var stampSize = getSize( stamp );\n    var offset = this._getElementOffset( stamp );\n    // get the columns that this stamp affects\n    var isOriginLeft = this._getOption('originLeft');\n    var firstX = isOriginLeft ? offset.left : offset.right;\n    var lastX = firstX + stampSize.outerWidth;\n    var firstCol = Math.floor( firstX / this.columnWidth );\n    firstCol = Math.max( 0, firstCol );\n    var lastCol = Math.floor( lastX / this.columnWidth );\n    // lastCol should not go over if multiple of columnWidth #425\n    lastCol -= lastX % this.columnWidth ? 0 : 1;\n    lastCol = Math.min( this.cols - 1, lastCol );\n    // set colYs to bottom of the stamp\n\n    var isOriginTop = this._getOption('originTop');\n    var stampMaxY = ( isOriginTop ? offset.top : offset.bottom ) +\n      stampSize.outerHeight;\n    for ( var i = firstCol; i <= lastCol; i++ ) {\n      this.colYs[i] = Math.max( stampMaxY, this.colYs[i] );\n    }\n  };\n\n  proto._getContainerSize = function() {\n    this.maxY = Math.max.apply( Math, this.colYs );\n    var size = {\n      height: this.maxY\n    };\n\n    if ( this._getOption('fitWidth') ) {\n      size.width = this._getContainerFitWidth();\n    }\n\n    return size;\n  };\n\n  proto._getContainerFitWidth = function() {\n    var unusedCols = 0;\n    // count unused columns\n    var i = this.cols;\n    while ( --i ) {\n      if ( this.colYs[i] !== 0 ) {\n        break;\n      }\n      unusedCols++;\n    }\n    // fit container to columns that have been used\n    return ( this.cols - unusedCols ) * this.columnWidth - this.gutter;\n  };\n\n  proto.needsResizeLayout = function() {\n    var previousWidth = this.containerWidth;\n    this.getContainerWidth();\n    return previousWidth != this.containerWidth;\n  };\n\n  return Masonry;\n\n}));\n"]},"metadata":{},"sourceType":"script"}